/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * LocalDisc is the Schema for the localdisks API
 */
export interface LocalDisk {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  metadata?: {};
  /**
   * spec defines the desired state of LocalDisk
   */
  spec?: {
    /**
     * device specifies the device path that is used at creation time. The device path of a disk may change at later time after node reboots.
     */
    device: string;
    /**
     * existingDataSkipVerify controls whether existing Spectrum Scale data structure should be overwritten when creating the disk.
     * A disk can have Spectrum Scale data structures on if it was used in a filesystem before and if it has not properly cleaned up.
     * If false, a "DiskHasFilesystemData" event is displayed if the disk still has Spectrum Scale data on it, and the disk will not be used.
     * If true, the disk will be formatted, no matter if it still has data on it.
     */
    existingDataSkipVerify?: boolean;
    /**
     * failureGroup is the failure group number for this disk. This parameter is only used if the filesystem that uses this disk is
     * replicated (means the Filesystem parameter spec.replication is "2-way" or "3-way"). The replicas of blocks are written to disks with
     * different failure group numbers.
     * Specify a positive number greater or equal than zero and use quotation marks, for example "2".
     * If this parameter is not specified, the failure group numbers are automatically assigned. Refer to the documentation for more
     * information on automatic failure group assignment.
     * This parameter cannot be changed anymore as soon as the local disk is used by a filesystem.
     */
    failureGroup?: string;
    /**
     * node specifies the kubernetes node name of node where the local disk device path (see "device" parameter) is gathered from at creation time.
     */
    node: string;
    /**
     * nodeConnectionSelector selects the nodes which are expected to have a physical connection to the disk. If not specified, all
     * nodes are expected to have a physical connection to the disk.
     * The operator verifies if the disks are visible on the selected nodes.
     * This parameter must not be specified if the disk is only connected to the node specified in spec.node, which means the disk type is "unshared".
     */
    nodeConnectionSelector?: {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: {
        /**
         * key is the label key that the selector applies to.
         */
        key: string;
        /**
         * operator represents a key's relationship to a set of values.
         * Valid operators are In, NotIn, Exists and DoesNotExist.
         */
        operator: string;
        /**
         * values is an array of string values. If the operator is In or NotIn,
         * the values array must be non-empty. If the operator is Exists or DoesNotExist,
         * the values array must be empty. This array is replaced during a strategic
         * merge patch.
         */
        values?: string[];
      }[];
      /**
       * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
       * map is equivalent to an element of matchExpressions, whose key field is "key", the
       * operator is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
        [k: string]: string;
      };
    };
    /**
     * thinDiskType specfies the space reclaim disk type of IBM Spectrum Scale disks (default: no)
     */
    thinDiskType?: "no" | "nvme" | "scsi" | "auto";
  };
  /**
   * status defines the observed state of LocalDisk
   */
  status?: {
    conditions?: {
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: string;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: number;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: "True" | "False" | "Unknown";
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       */
      type: string;
    }[];
    /**
     * failuregroup is the failuregroup number for this localdisk. The replicas of data blocks are written to localdisks with different failuregroup numbers.
     */
    failuregroup: string;
    /**
     * failuregroupMapping describes to which Kubernetes object the failuregroup is mapped to during automatic failuregroup assignment.
     * This can be a Kubernetes node, a Kubernetes zone or a Kubernetes region. This is empty if the failure group number is configured in spec.failureGroup.
     */
    failuregroupMapping?: string;
    /**
     * filesystem is the name of the filesystem that uses this localdisk. If this is empty, the localdisk is not used by a filesystem.
     */
    filesystem: string;
    /**
     * nodeConnections is the list of nodes that have a connection to the disk.
     */
    nodeConnections: string;
    /**
     * pool is the name of the filesystem pool that uses this localdisk. If this is empty, the localdisk is not used by a filesystem.
     */
    pool: string;
    /**
     * size is the size of the localdisk
     */
    size: string;
    /**
     * type of the localdisk. This is "shared" if the disk is connected to all core pods (or the pods selected by spec.nodeConnectionSelector). This is "partially-shared" if the disk is connected to only a subset of all core pods (or the pods selected by spec.nodeConnectionSelector). This is "unshared" if the disk is only connected to one core pod.
     */
    type: string;
  };
}
