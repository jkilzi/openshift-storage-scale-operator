/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Daemon is the Schema for the daemons API
 */
export interface Daemon {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string;
  metadata?: {};
  /**
   * spec defines the desired state of Daemon
   */
  spec?: {
    /**
     * clusterName overrides the default name, which is that of the Daemon resource itself postpended with any resolved domain suffix.
     */
    clusterNameOverride?: string;
    /**
     * IBM Spectrum Scale configuration parameters for the cluster.
     * Changing these values is unsupported and should
     * not be changed unless advised by IBM Support
     */
    clusterProfile?: {
      afmAsyncDelay?: string;
      afmDIO?: string;
      afmHashVersion?: string;
      afmMaxParallelRecoveries?: string;
      afmObjKeyExpiration?: string;
      backgroundSpaceReclaimThreshold?: string;
      cloudEnv?: "general";
      controlSetxattrImmutableSELinux?: string;
      encryptionKeyCacheExpiration?: string;
      enforceFilesetQuotaOnRoot?: string;
      ignorePrefetchLUNCount?: string;
      ignoreReplicaSpaceOnStat?: "yes" | "no";
      ignoreReplicationForQuota?: "yes" | "no";
      ignoreReplicationOnStatfs?: "yes" | "no";
      initPrefetchBuffers?: string;
      maxBufferDescs?: string;
      maxMBpS?: string;
      maxTcpConnsPerNodeConn?: string;
      maxblocksize?: string;
      nsdMaxWorkerThreads?: string;
      nsdMinWorkerThreads?: string;
      nsdMultiQueue?: string;
      nsdRAIDBlockDeviceMaxSectorsKB?: string;
      nsdRAIDBlockDeviceNrRequests?: string;
      nsdRAIDBlockDeviceQueueDepth?: string;
      nsdRAIDBlockDeviceScheduler?: string;
      nsdRAIDBufferPoolSizePct?: string;
      nsdRAIDDefaultGeneratedFD?: string;
      nsdRAIDDiskCheckVWCE?: string;
      nsdRAIDEventLogToConsole?: string;
      nsdRAIDFlusherFWLogHighWatermarkMB?: string;
      nsdRAIDMasterBufferPoolSize?: string;
      nsdRAIDMaxPdiskQueueDepth?: string;
      nsdRAIDMaxRecoveryRetries?: string;
      nsdRAIDMaxTransientStale2FT?: string;
      nsdRAIDMaxTransientStale3FT?: string;
      nsdRAIDNonStealableBufPct?: string;
      nsdRAIDReadRGDescriptorTimeout?: string;
      nsdRAIDReconstructAggressiveness?: string;
      nsdRAIDSmallThreadRatio?: string;
      nsdRAIDThreadsPerQueue?: string;
      nsdRAIDTracks?: string;
      nsdSmallThreadRatio?: string;
      nspdBufferMemPerQueue?: string;
      nspdQueues?: string;
      nspdThreadsPerQueue?: string;
      numaMemoryInterleave?: string;
      pagepoolMaxPhysMemPct?: string;
      panicOnIOHang?: string;
      pitWorkerThreadsPerNode?: string;
      prefetchPct?: string;
      prefetchThreads?: string;
      prefetchTimeout?: string;
      proactiveReconnect?: "yes" | "no";
      qMaxBlockShare?: string;
      qRevokeDisable?: string;
      readReplicaPolicy?: "default" | "local" | "fastest";
      seqDiscardThreshold?: string;
      traceGenSubDir?: "/var/mmfs/tmp/traces";
      tscCmdAllowRemoteConnections?: "yes" | "no";
      tscCmdPortRange?: string;
      verbsPorts?: string;
      verbsRdma?: "enable" | "disable";
      verbsRdmaCm?: "enable" | "disable";
      verbsRdmaSend?: "yes" | "no";
    };
    /**
     * It specifies the IBM Spectrum Scale edition, "data-access" or "data-management".
     */
    edition: "data-access" | "data-management" | "erasure-code";
    /**
     * hostAliases that will be added to the internal DNS that resolves hosts for core pods
     */
    hostAliases?: {
      /**
       * Hostname for the associated IP address.
       */
      hostname: string;
      /**
       * IP address of the host file entry.
       */
      ip: string;
    }[];
    /**
     * Deprecated: use ClusterManagerConfigSpec.Spec.Images instead.
     * core and init image pair that daemon will use with respect to edition specified by user
     */
    images?: {
      core?: string;
      coreInit?: string;
    };
    /**
     * nodeSelector will be applied to daemon core pods. The selectors in this field are ANDed.
     * This means that only nodes are selected which have all labels of this field.
     * This field is logically ANDed with any nodeSelectorExpressions also configured.
     */
    nodeSelector?: {
      [k: string]: string;
    };
    /**
     * nodeSelectorExpressions that will apply to daemon core pods. This field is logically ANDed with any nodeSelector also configured.
     */
    nodeSelectorExpressions?: {
      /**
       * The label key that the selector applies to.
       */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: string;
      /**
       * An array of string values. If the operator is In or NotIn,
       * the values array must be non-empty. If the operator is Exists or DoesNotExist,
       * the values array must be empty. If the operator is Gt or Lt, the values
       * array must have a single element, which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values?: string[];
    }[];
    /**
     * nsdDevicesConfig allows users to specify non-standard device names in order to override or enhance the disk discovery process.
     * This parameter must only be specified when using a local filesystem with devices that use non-standard device names.
     */
    nsdDevicesConfig?: {
      /**
       * bypassDiscovery allows bypass of automatic disk discovery. If set to true, only the set of devices
       * defined by the localDevicePaths will be used. If set to false, the automatic device discovery will find
       * devices with standard device names.
       */
      bypassDiscovery?: true | false;
      /**
       * localDevicePaths specifies the device names and device types.
       */
      localDevicePaths?: {
        /**
         * devicePath specifies nsd device names. Allows wildcards.
         * For example: '/dev/sdd', '/dev/pvc*', ...
         */
        devicePath?: string;
        /**
         * deviceType specifies the device type.
         * For example: 'dmm', 'vpath', 'generic', ...
         */
        deviceType?: string;
      }[];
    };
    /**
     * regionalDR contains daemon configuration information for regionaldr
     */
    regionalDR?: {};
    /**
     * roles specify the IBM Spectrum Scale configuration parameters for nodes that apply to a role.
     * Specifying configuration parameters for roles is optional and does overwrite a set of default parameters.
     */
    roles?: {
      /**
       * The Memory/CPU resource limits that will be set for Scale core pods.
       */
      limits?: {
        /**
         * CPU is measured in cpu units (i.e 1, 2, 100m, 2500m)
         */
        cpu?: string;
        /**
         * Memory is measured in bytes as plain integer or with kubernetes supported suffixes (i.e 128974848, 129e6, 129M, 123Mi).
         * The value is the maximum amount of memory the Scale core pod is allowed to consume.
         */
        memory?: string;
      };
      /**
       * Name of the role. Only afm, storage or client are allowed.
       */
      name?: "afm" | "storage" | "client";
      /**
       * IBM Spectrum Scale node-scoped configuration parameters.
       * Changing these values is unsupported and should
       * not be changed unless advised by IBM Support
       */
      profile?: {
        afmMaxParallelRecoveries?: string;
        backgroundSpaceReclaimThreshold?: string;
        controlSetxattrImmutableSELinux?: string;
        ignorePrefetchLUNCount?: string;
        initPrefetchBuffers?: string;
        maxBufferDescs?: string;
        maxMBpS?: string;
        maxTcpConnsPerNodeConn?: string;
        maxblocksize?: string;
        nsdMaxWorkerThreads?: string;
        nsdMinWorkerThreads?: string;
        nsdMultiQueue?: string;
        nsdRAIDBlockDeviceMaxSectorsKB?: string;
        nsdRAIDBlockDeviceNrRequests?: string;
        nsdRAIDBlockDeviceQueueDepth?: string;
        nsdRAIDBlockDeviceScheduler?: string;
        nsdRAIDBufferPoolSizePct?: string;
        nsdRAIDDefaultGeneratedFD?: string;
        nsdRAIDDiskCheckVWCE?: string;
        nsdRAIDEventLogToConsole?: string;
        nsdRAIDFlusherFWLogHighWatermarkMB?: string;
        nsdRAIDMasterBufferPoolSize?: string;
        nsdRAIDMaxPdiskQueueDepth?: string;
        nsdRAIDMaxRecoveryRetries?: string;
        nsdRAIDMaxTransientStale2FT?: string;
        nsdRAIDMaxTransientStale3FT?: string;
        nsdRAIDNonStealableBufPct?: string;
        nsdRAIDReadRGDescriptorTimeout?: string;
        nsdRAIDReconstructAggressiveness?: string;
        nsdRAIDSmallThreadRatio?: string;
        nsdRAIDThreadsPerQueue?: string;
        nsdRAIDTracks?: string;
        nsdSmallThreadRatio?: string;
        nspdBufferMemPerQueue?: string;
        nspdQueues?: string;
        nspdThreadsPerQueue?: string;
        numaMemoryInterleave?: string;
        pagepoolMaxPhysMemPct?: string;
        panicOnIOHang?: string;
        pitWorkerThreadsPerNode?: string;
        prefetchPct?: string;
        prefetchThreads?: string;
        prefetchTimeout?: string;
        proactiveReconnect?: "yes" | "no";
        seqDiscardThreshold?: string;
        tscCmdPortRange?: string;
        verbsPorts?: string;
        verbsRdma?: "enable" | "disable";
        verbsRdmaCm?: "enable" | "disable";
        verbsRdmaSend?: "yes" | "no";
      };
      /**
       * The Memory/CPU resource requests that will be set for Scale core pods.
       */
      resources?: {
        /**
         * CPU is measured in cpu units (i.e 1, 2, 100m, 2500m)
         */
        cpu?: string;
        /**
         * Memory is measured in bytes as plain integer or with kubernetes supported suffixes (i.e 128974848, 129e6, 129M, 123Mi).
         * The value is a target and will be requested for Scale core pods.
         * Resource request limits on containers impact pod scheduling and bin packing.
         */
        memory?: string;
      };
    }[];
    /**
     * Specifies the site name and zone for daemon name resolution.
     */
    site: {
      /**
       * name is the site name.
       */
      name: string;
      /**
       * zone is the domain name that IBM Spectrum Scale DNS records for this site will be managed.
       * This will be used to resolve node names for IBM Spectrum Scale.
       */
      zone: string;
    };
    /**
     * tolerations that are applied to daemon core pods.
     */
    tolerations?: {
      /**
       * Effect indicates the taint effect to match. Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: string;
      /**
       * Key is the taint key that the toleration applies to. Empty means match all taint keys.
       * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Operator represents a key's relationship to the value.
       * Valid operators are Exists and Equal. Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can
       * tolerate all taints of a particular category.
       */
      operator?: string;
      /**
       * TolerationSeconds represents the period of time the toleration (which must be
       * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
       * it is not set, which means tolerate the taint forever (do not evict). Zero and
       * negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
    }[];
    /**
     * update defines the update behavior of the Scale core pods. If not specified, all core pods are updated one by one.
     */
    update?: {
      /**
       * maxUnavailable defines either an integer number or percentage of core pods
       * and nodes that can go Unavailable during an update. This only affects core
       * pods that do not reside in any update pool (see `pools` parameter).
       * The default value is 1. A value larger than 1 will mean multiple core pods
       * and nodes going unavailable during the update, which causes that PV storage
       * of Storage Scale CSI is unavailable and may affect your workload stress on
       * the remaining nodes. You cannot set this value to 0 to stop updates;
       * to stop updates, use the 'paused' property instead.
       */
      maxUnavailable?: number | string;
      /**
       * paused specifies whether or not updates should be stopped. This only affects
       * core pods that do not reside in any update pool (see `pools` parameter).
       */
      paused?: boolean;
      /**
       * pools describe a set of update pools. An update pool describes the update
       * behavior of selected core pods, for example how many pods can be updated in
       * parallel.
       */
      pools?: {
        /**
         * maxUnavailable defines either an integer number or percentage of core pods
         * and nodes in the pool that can go Unavailable during an update.
         * The default value is 1. A value larger than 1 will mean multiple core pods
         * and nodes going unavailable during the update, which causes that PV storage
         * of Storage Scale CSI is unavailable and may affect your workload stress on
         * the remaining nodes. You cannot set this value to 0 to stop updates;
         * to stop updates, use the 'paused' property instead.
         * This parameter must not be specified if the update pool references to an
         * Openshift MachineConfigPool (means pool name has "mcp/" prefix).
         */
        maxUnavailable?: number | string;
        /**
         * name is the name of the update pool. This pool references to an OpenShift
         * MachineConfigPool if the name has a "mcp/" prefix (for example "mcp/worker").
         */
        name: string;
        /**
         * nodeSelector selects the Kubernetes nodes that host the core pods that belong
         * to this update pool. Nodes that do not host a core pod are ignored.
         * This parameter must not be specified if the update pool references to an
         * Openshift MachineConfigPool (means pool name has "mcp/" prefix).
         */
        nodeSelector?: {
          /**
           * matchExpressions is a list of label selector requirements. The requirements are ANDed.
           */
          matchExpressions?: {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[];
          }[];
          /**
           * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
           * map is equivalent to an element of matchExpressions, whose key field is "key", the
           * operator is "In", and the values array contains only "value". The requirements are ANDed.
           */
          matchLabels?: {
            [k: string]: string;
          };
        };
        /**
         * paused specifies whether or not updates to this update pool should be stopped.
         * This parameter is ignored if the update pool references to an Openshift
         * MachineConfigPool (means pool name has "mcp/" prefix).
         */
        paused?: boolean;
      }[];
    };
  };
  /**
   * status defines the observed state of Daemon
   */
  status?: {
    /**
     * ID representing GPFS cluster
     */
    clusterID?: string;
    /**
     * Name of GPFS cluster
     */
    clusterName?: string;
    conditions?: {
      /**
       * lastTransitionTime is the last time the condition transitioned from one status to another.
       * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
       */
      lastTransitionTime: string;
      /**
       * message is a human readable message indicating details about the transition.
       * This may be an empty string.
       */
      message: string;
      /**
       * observedGeneration represents the .metadata.generation that the condition was set based upon.
       * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
       * with respect to the current state of the instance.
       */
      observedGeneration?: number;
      /**
       * reason contains a programmatic identifier indicating the reason for the condition's last transition.
       * Producers of specific condition types may define expected values and meanings for this field,
       * and whether the values are considered a guaranteed API.
       * The value should be a CamelCase string.
       * This field may not be empty.
       */
      reason: string;
      /**
       * status of the condition, one of True, False, Unknown.
       */
      status: "True" | "False" | "Unknown";
      /**
       * type of condition in CamelCase or in foo.example.com/CamelCase.
       * ---
       * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
       * useful (see .node.status.conditions), the ability to deconflict is important.
       * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
       */
      type: string;
    }[];
    /**
     * Details about nodes that are cordoned and drained and pods that are evicted by Scale operator.
     */
    cordonAndDrain?: {
      /**
       * List of nodes that are cordoned by Scale operator. These nodes have status SchedulingDisabled. Nodes that are cordoned by third party like machine config operator are not listed.
       */
      nodesCordonedByOperator: string;
      /**
       * List of nodes that are cordoned by third party like machine config operator. These nodes have status SchedulingDisabled. Nodes that are cordoned by Scale operator are not listed.
       */
      nodesCordonedByOthers: string;
      /**
       * List of nodes on which the Scale operator is currently evicting pods
       */
      nodesDraining?: {
        /**
         * The node that is currently drained by the Scale operator
         */
        node: string;
        /**
         * The pods that the Scale operator is currently evicting
         */
        ongoingPodEvictions: string[];
        /**
         * The pods that failed to evict. The Scale operator continues to try to evict these pods.
         */
        podEvictionsFailed: string[];
      }[];
      /**
       * List of daemon core pod evictions that are requested by third party (like machine config operator).
       */
      podEvictionRequests?: {
        /**
         * Scale core pods that has been requested for eviction.
         */
        pods: string;
        /**
         * Name of requestor that requests the eviction of the pod.
         */
        requestor: string;
      }[];
    };
    /**
     * The currently enabled level of functionality of the cluster. It is expressed as an IBM Spectrum Scale version number, such as 5.0.2.0.
     */
    minimumReleaseLevel?: string;
    pods?: {
      /**
       * Number of desired core pods
       */
      desired: string;
      /**
       * Number of existing core pods
       */
      total: string;
    };
    podsStatus?: {
      /**
       * Number of running core pods
       */
      running: string;
      /**
       * Number of starting core pods
       */
      starting: string;
      /**
       * Number of terminating core pods
       */
      terminating: string;
      /**
       * Number of core pods with unknown status. Pods scheduled on unreachable nodes are listed here.
       */
      unknown: string;
      /**
       * Number of core pods that will be deleted
       */
      waitingForDelete: string;
    };
    quorumPods?: {
      /**
       * Number of running quorum pods
       */
      running: string;
      /**
       * Total number of quorum pods
       */
      total: string;
    };
    roles?: {
      /**
       * Name of the role
       */
      name: string;
      /**
       * Number of nodes that that are assigned to this role. Nodes are assigned to a role by label, i.e. "scale.spectrum.ibm.com/role=client"
       */
      nodeCount: string;
      /**
       * List of nodes that are assigned to the role
       */
      nodes: string;
      /**
       * Number of role pods
       */
      podCount: string;
      /**
       * List of role pods
       */
      pods: string;
      /**
       * Number of running role pods
       */
      runningCount: string;
    }[];
    statusDetails?: {
      /**
       * List of core pod nodes that are currently rebooting
       */
      nodesRebooting: string;
      /**
       * List of core pod nodes that are unreachable
       */
      nodesUnreachable: string;
      /**
       * List of starting core pods
       */
      podsStarting: string;
      /**
       * List of terminating core pods
       */
      podsTerminating: string;
      /**
       * List of core pods with unknown status. Pods scheduled on unreachable nodes are listed here.
       */
      podsUnknown: string;
      /**
       * List of core pods that will be deleted soon
       */
      podsWaitingToBeDeleted?: {
        /**
         * Reason for deleting the core pods
         */
        deleteReason: string;
        /**
         * List of core pods that will be deleted soon
         */
        pods: string;
      }[];
      /**
       * List of pods that act as quorum node for Spectrum Scale
       */
      quorumPods: string;
    };
    tiebreaker?: {
      version?: string;
    };
    update?: {
      pools?: {
        name: string;
        nodeCount: number;
        nodes: string;
      }[];
    };
    /**
     * Details about version of each node in IBM Spectrum Scale cluster. It contains the version of nodes in the other site if it's a stretch cluster.
     */
    versions?: {
      /**
       * Number of pods that that have this version
       */
      count: string;
      /**
       * List of pods that have this version
       */
      pods?: string;
      /**
       * The site name in a stretch cluster environment
       */
      site?: string;
      /**
       * Value of the pod's product version (expected format is x.x.x.x or "unavailable" if pod is unavailable)
       */
      version: string;
    }[];
  };
}
